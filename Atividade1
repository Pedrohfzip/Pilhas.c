#include <stdio.h>
#include <stdlib.h>

typedef struct Elemento{
    struct Elemento *proximo;
    struct Elemento *previous;
    char dado;
} Elemento;



typedef struct Pilha{

    struct Elemento* tail;
    struct Elmento* head;
    int size;

}Pilha;


Pilha* criaPilha();
Elemento* criaElemento(char);
void push(Pilha*,char);
int pop(Pilha*);
void mostrarPilha(Pilha*);
void liberaPilha(Pilha*);
char escreverOperacao();
char mostrarOperacao();
int validarEscopos(Pilha*,Pilha*,Pilha*,Pilha*);
Elemento* primeiroFila(Pilha*);



int main(){

Pilha* pilha = criaPilha();
Pilha* pilhaParenteses = criaPilha();
Pilha* pilhaColchetes = criaPilha();
Pilha* pilhaChaves = criaPilha();
Pilha* pilhaEscopos = criaPilha();


//=====================

    escreverOperacao(pilha);

    mostrarPilha(pilha);

    compararCaracter(pilha,pilhaEscopos);
    printf("\n");

    validarEscopos(pilhaEscopos,pilhaParenteses,pilhaColchetes,pilhaChaves);
     printf("\n");




}


//=============================================

Elemento* criaElemento(char dado){
    Elemento *novo = (Elemento*) malloc(sizeof(Elemento));
    novo->proximo = NULL;
    novo->previous = NULL;
    novo->dado = dado;
    return novo;
}

//=============================================

Pilha* criaPilha(){
  Pilha* pilha = (Pilha*) malloc(sizeof(Pilha));
  pilha->head = NULL;
  pilha->tail = NULL;
  pilha->size = 0;

  return pilha;
}

//=============================================

void push(Pilha* pilha,char dado){
    Elemento* novo_elemento = criaElemento(dado);
    novo_elemento->dado = dado;

    if(pilha->size == 0){

        pilha->head = novo_elemento;
        pilha->tail = novo_elemento;

    }else{
        novo_elemento->proximo = NULL;
        novo_elemento->previous = pilha->tail;
        pilha->tail->proximo = novo_elemento;
        pilha->tail = novo_elemento;
    }

    pilha->size++;
}

//=============================================


int pop(Pilha* pilha){
    Elemento* removendo = pilha->tail;
      if(removendo == pilha->head && pilha->size > 0){
        pilha->head = removendo->proximo;
        pilha->tail = NULL;
      }else if(pilha->size > 0){
      removendo->previous->proximo = NULL;
      pilha->tail = removendo->previous;
    }else{
      printf("Erro na remoção \n");
      return -1;
    }
    free(removendo);
    pilha->size--;
    return 0;

}

//=============================================



void mostrarPilha(Pilha* pilha){
    Elemento* aux = pilha->head;
    if(pilha->size == 0){
        printf("Lista Vazia");
    }

    while(aux != NULL){
        char palavra = aux->dado;
        printf("%c", palavra);
        aux = aux->proximo;
    }
}

//=============================================

void compararCaracter(Pilha* pilhaOperacao,Pilha* pilhaEscopo){
    Elemento* auxOperacao = pilhaOperacao->head;
    char caracterOper;
    while(auxOperacao != NULL){
        caracterOper = auxOperacao->dado;
            if(caracterOper == ')'){
                push(pilhaEscopo,caracterOper);
            }else if(caracterOper == '('){
                push(pilhaEscopo,caracterOper);
            }else if(caracterOper == '['){
                push(pilhaEscopo,caracterOper);
            }else if(caracterOper == ']'){
                push(pilhaEscopo,caracterOper);
            }else if(caracterOper == '{'){
                push(pilhaEscopo,caracterOper);
            }else if(caracterOper == '}'){
                push(pilhaEscopo,caracterOper);
            }

        auxOperacao = auxOperacao->proximo;
    }

}


//=============================================


void liberaPilha(Pilha* pilha){
    Elemento* aux = pilha->tail;

    while(aux != NULL){
        free(aux);
        aux = aux->proximo;

    }
}

//=============================================

Elemento* primeiroDaFila(Pilha* pilha){

    return pilha->head;
}

//=============================================

char escreverOperacao(Pilha* pilha){
char operacao[30];

printf("Digite a operacao: ");
    scanf("%s", &operacao);
    for(int i=0;i<30;i++){
        if(operacao[i] == NULL){
            return;
        }
        push(pilha, operacao[i]);
    }



}

//=============================================

int validarEscopos(Pilha* pilha,Pilha* pilhaParenteses,Pilha* pilhaColchetes,Pilha* pilhaChaves){
    Elemento* aux = pilha->head;
    char escopos;
    int contParenteses = 0;
    int contColchetes = 0;
    int contChaves = 0;
    int soma = 0;
    while(aux != NULL){
        escopos = aux->dado;
            if(escopos == ')'){
                push(pilhaParenteses,escopos);
                contParenteses++;
            }else if(escopos == '('){
                push(pilhaParenteses,escopos);
                contParenteses++;
            }else if(escopos == '['){
                push(pilhaColchetes,escopos);
                contColchetes++;
            }else if(escopos == ']'){
                push(pilhaParenteses,escopos);
                contColchetes++;
            }else if(escopos == '{'){
                push(pilhaChaves,escopos);
                contChaves++;
            }else if(escopos == '}'){
                push(pilhaChaves,escopos);
                contChaves++;
            }
        aux = aux->proximo;
    }
    soma = contParenteses + contColchetes + contChaves;
    if(soma % 2 == 0){
        printf("Operacao invalida falta de escopos");
    }
}
